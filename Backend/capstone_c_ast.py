# -*- coding: utf-8 -*-
"""Capstone_C_AST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15gNt_lVggwyJ53V6WOiJTrrd5UoYgDYF

##Installing the required packages
"""

#!pip install pycparser

#!pip install anytree

#!pip show pycparser

#import os
#os.listdir('/usr/local/lib/python3.7/dist-packages/pycparser')

import pycparser #make sure the version is 2.21

from anytree import Node
import random


"""##Generating AST for the code"""

def get_ast(filename):
    ast = pycparser.parse_file(filename, use_cpp=True)  
    #parser = c_parser.CParser()
    #ast = parser.parse(func, filename='<none>')
    #print(ast)
    return ast

"""##Getting the tokens from the nodes"""

def get_token(node):
    token = ''
    if isinstance(node, pycparser.c_ast.FileAST):
        token = node.__class__.__name__
        return token
    elif isinstance(node[1], str):
        token = node[1]
        return token
        #print(token)
    elif isinstance(node[1], pycparser.c_ast.Node):
        token = node[1].__class__.__name__
    #print(token)
    
    if len(get_children(node))==0:
        attr_names = node[1].attr_names
        if attr_names:
            if 'names' in attr_names:
                token = node[1].names[0]
            elif 'name' in attr_names:
                token = node[1].name
            else:
                token = node[1].value
    else:
        if token == 'TypeDecl':
            token = node[1].declname
        if node[1].attr_names:
            attr_names = node[1].attr_names
            if 'op' in attr_names:
                if node[1].op[0] == 'p':
                    token = node[1].op[1:]
                else:
                    token = node[1].op
 
    if token == '':
        token = node[1].__class__.__name__
    return token

"""##Getting the children nodes and getting a tree """

def get_children(root):
    if isinstance(root, pycparser.c_ast.FileAST):
        children = root.children()
    elif isinstance(root[1], pycparser.c_ast.Node):
        children = root[1].children()
    elif isinstance(root, set):
        children = list(root)
    else:
        children = []

    def expand(nested_list):
        for item in nested_list:
            if isinstance(item, list):
                for sub_item in expand(item):
                    yield sub_item
            elif item:
                yield item

    return list(expand(children))

def get_trees(current_node, parent_node, order,nodes):
    token, children = get_token(current_node), get_children(current_node)
    node = Node([order,token], parent=parent_node, order=order)
    #print(parent_node)
    #if(parent_node.name=='')
    p = str(parent_node.name[0])+"--"+str(parent_node.name[1])
    c = str(order)+"--"+str(token)
    nodes.append((p,c))
    #print(nodes)
    for child_order in range(len(children)):
        get_trees(children[child_order], node, order+str(random.randint(1,100000)+1),nodes)

#c_code = ast
#ast = program_parser(filename)

def get_c_nodes(filename):
  #get the ast
  c_ast = get_ast(filename)
  
  # Initialize head node of the code.
  head = Node(["1",get_token(c_ast)])
  
  # Recursively construct AST tree and get all the nodes in nodes list
  nodes = []
  #nodes.append((None,str(head.name[1])+str(head.name[0])))
  for child_order in range(len(get_children(c_ast))):
      get_trees(get_children(c_ast)[child_order], head, "1"+str(int(child_order)+1),nodes)
  
  return nodes,head


"""##Removing typedef nodes and their children"""

#getting the parent and children in separate lists

def get_parent_child(nodes):
  parents=[]
  children=[]

  for i in nodes:
    parents.append(i[0])
    children.append(i[1])

  return(parents,children)

#getting all the children of the given node

def get_all_children(parents,node,children,rem_indices):
  for i in range(len(parents)):
    if node==parents[i]: #check if the node is in the list of parents 
      #print(node)
      #print(i)
      rem_indices.append(i) #if yes append the index

#removing all the typedef nodes and the children

def get_typedef(parents,children):
  rem_indices=[] #to get the indices to be removed
  i=0 #to get the current index

  #traverse the whole list of parents
  while(i<len(parents)):
    
    if 'Typedef' in children[i]:
      rem_indices.append(i) #append i to rem_indices
      child=children[i] #get the child of the current parent
      
      while((child in parents)):
        get_all_children(parents,child,children,rem_indices) #append all the children of the current parent
        i+=1 
        child=children[i] #get the children of the current parent
      
    i+=1 #increment the index
    
  return rem_indices


#traverse through the rem_indices list and remove the nodes 

def remove_nodes(rem_indices,nodes):
  rem_nodes=[]
  
  for i in rem_indices:
    rem_nodes.append(nodes[i])
  
  nodes_1=list(set(nodes)-set(rem_nodes))
  
  return nodes_1

#function call to get the req codes

def get_req_nodes(nodes):
  l= get_parent_child(nodes)
  parents,children=l[0],l[1]
  
  rem_indices=get_typedef(parents,children)
  
  nodes_1 = remove_nodes(rem_indices,nodes)
  
  return nodes_1

#nodes = get_req_nodes(nodes)

#len(nodes)

def rem_newline(item):
    item = item.replace('\n',"")
    item = item.replace('\t',"")
    return item

"""##Writing nodes into a file"""

def write_nodes(target,nodes):
  with open(target, 'w') as fp:
      for item in nodes:
          # write each item on a new line
          #print(item[0],item[1])
          item0=rem_newline(item[0])
          item1=rem_newline(item[1])
          #print(item0,item1)
          fp.write(str(item0)+","+str(item1)+"\n")
      print('Done C nodes')

def c_nodes(filename, target):
  #filename = '/content/testPP.c'
  l = get_c_nodes(filename)
  nodes = l[0]
  tree=l[1]
  nodes = get_req_nodes(nodes)
  write_nodes(target,nodes)

#filename = 'testPP.c'
#target = 'c_nodes.txt'
#c_nodes(filename,target)

