# -*- coding: utf-8 -*-
"""Capstone_Java_AST

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g-j9C1XyasN0MuzanssDgklAby1FU1a1

#Installing and importing the required libraries
"""

#!pip install javalang

#!pip install anytree

import javalang
import re
import random
from anytree import Node


"""#Generating AST by reading the filename"""

#tokens = javalang.tokenizer.tokenize(text)
def get_ast(filename):
  f = open(filename, "r")
  text = f.read()
  out = re.sub('//.*?\n|/\*.*?\*/', '', text, flags=re.S)
  #print(out)
  tree = javalang.parse.parse(out)
  return tree
#parser.parse_expression()

#print(tree)

#javalang.ast.walk_tree(tree)

"""#Getting the token of each node"""

def get_token(root):
  token=""
  if type(root)==str:
    token=root
    return token
  else:
    token = root.__class__.__name__
    return token

"""#Getting the child nodes of each parent node"""

def get_children(root):
    if root.__class__.__name__=='CompilationUnit':
        #print(root)
        children = root.children
    #elif root.__class__.__name__=='ReferenceType':
        #print(root)
    #    children = root.children
    #elif ((root==None) or (type(root)==list and (len(root)==0 or root[0]==None))):
    #  children=[]
    elif isinstance(root, set):
        children = list(root)
    #elif type(root)==str:
    #    children = list(root)
    elif isinstance(root, javalang.ast.Node):
         children = root.children
    else:
        #print(root)
        children = []
    #print(children)
    
    def expand(nested_list):
        for item in nested_list:
            if isinstance(item, list):
                for sub_item in expand(item):
                    yield sub_item
            elif item:
                yield item
    #print(list(expand(children)))
    return list(expand(children))
    
    #return children

"""#Calling both the above functions to collect all the nodes into a list """

def get_trees(current_node, parent_node, order,nodes):
    #print(current_node)
    #fields = list(ast.iter_fields(current_node))
    #print(fields)
    token, children = get_token(current_node), get_children(current_node)
    node = Node([order,token], parent=parent_node, order=order)
    #print(parent_node)
    #if(parent_node.name=='')
    p = str(parent_node.name[0])+"--"+str(parent_node.name[1])
    c = str(order)+"--"+str(token)
    nodes.append((p,c))
    #print(nodes)
    #print(children)
    for child_order in range(len(children)):
        #print(order)
        get_trees(children[child_order], node, order+str(random.randint(1,100000)+1),nodes)

def get_java_nodes(filename):
  tree = get_ast(filename)
  # Initialize head node of the code.
  
  head = Node(["1",tree.__class__.__name__])
  # Recursively construct AST tree.
  nodes = []
  #nodes.append((None,str(head.name[1])+str(head.name[0])))
  #print(get_children(tree))
  for child_order in range(len(get_children(tree))):
      #print(child_order)
      #print(get_children(tree)[child_order])
      get_trees(get_children(tree)[child_order], head,"1"+str(int(child_order)+1), nodes)

  return nodes,head

#removing newline and tab spaces 
def rem_newline(item):
    item = item.replace('\n',"")
    item = item.replace('\t',"")
    return item

"""#Writing the nodes into a text file"""

def write_nodes(target,nodes):
  with open(target, 'w') as fp:
      for item in nodes:
          # write each item on a new line
          item0=rem_newline(item[0])
          item1=rem_newline(item[1])
          #print(item0,item1)
          fp.write(str(item0)+","+str(item1)+"\n")
      print('Done java nodes')

def java_nodes(filename, target):
  #filename = '/content/testPP.c'
  l = get_java_nodes(filename)
  nodes = l[0]
  tree=l[1]
  write_nodes(target,nodes)

#filename = 'hello.java'
#target='java_nodes.txt'
#java_nodes(filename,target)

